# 生产管理功能开发文档（更新版）

## 1. 功能概述

生产管理模块用于管理注塑生产计划安排和生产记录，核心功能是**根据生产订单自动生成生产计划**，查看在指定时间内是否能够完成生产目标。系统根据生产订单（包含机台号、产品名称、订单数量、产能），按机台号自动生成生产计划排程，避开星期天，并实时计算剩余数量。

## 2. 功能需求

### 2.1 生产订单管理

#### 2.1.1 生产订单录入
在新增生产订单时，需要输入以下信息：
- **机台号**（必填）：机台编号，用于关联设备
- **产品名称**（必填）：要生产的产品名称
- **订单数量**（必填）：该产品的订单数量
- **产能**（必填）：该机台生产该产品的日产能（每天能生产的数量）

#### 2.1.2 生产订单管理功能
- 生产订单列表查询（支持按机台号、产品名称查询）
- 生产订单新增、编辑、删除
- 支持一个机台号配置多个产品订单（按录入顺序确定生产优先级）
- 订单信息：机台号、产品名称、订单数量、产能、创建时间等

### 2.2 生产计划排程（核心功能）

#### 2.2.1 排程目标
- 根据生产订单自动生成生产计划
- 按机台号维度生成排程计划
- 自动计算每天的生产安排和剩余数量
- 查看在指定时间内是否能够完成生产目标

#### 2.2.2 排程规则
1. **按机台号维度**：在生产计划页面对应机台号后面按日生成生产计划
2. **按产品优先级**：每个机台号按订单录入顺序进行生产（先录入的产品先生产）
3. **剩余数量计算**：`剩余数量 = 订单数量 - 产能 × 已生产天数`
4. **产品切换规则**：
   - 当某个产品的剩余数量 ≤ 0 时，停止计算该产品
   - 开始排序下一种产品（按订单录入顺序）
   - 以此类推，若剩余数量为0则停止计算并且开始排序下一种产品
5. **避开星期天**：排程时自动跳过星期天，不在星期天安排生产
6. **排产数量**：每天排产数量等于该产品的产能数量

#### 2.2.3 排程结果展示
对于每个机台号，显示排程计划：
- **机台号**：机台编号
- **日期**：排程日期（避开星期天）
- **产品名称**：当天生产的产品名称
- **排产数量**：当天该产品的产能数量（排产数量 = 产能）
- **剩余数量**：该产品在该机台号上的剩余订单数量
  - 计算公式：`剩余数量 = 订单数量 - 产能 × 已生产天数`
  - 当剩余数量 ≤ 0 时，该产品完成，切换到下一个产品

#### 2.2.4 排程查询功能
- 支持按机台号查询
- 支持查看单个机台号的排程计划
- 支持查看所有机台号的排程汇总
- 支持导出排程报表

### 2.3 生产记录管理
- 生产记录录入（关联排程计划）
- 记录列表查询
- 记录信息：设备、产品、产量、不良品数量、生产日期等

### 2.4 生产目标完成情况分析
- 27天内总产能统计
- 各产品完成情况统计
- 各设备产能利用率统计
- 是否能在27天内完成生产目标的判断

## 3. 数据库设计

### 3.1 设备表（equipment）- 扩展字段

```sql
CREATE TABLE `equipment` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `equipment_no` varchar(50) NOT NULL COMMENT '设备编号（唯一）',
  `equipment_name` varchar(100) NOT NULL COMMENT '设备名称',
  `group_name` varchar(50) DEFAULT NULL COMMENT '组别',
  `machine_no` varchar(50) DEFAULT NULL COMMENT '机台号',
  `equipment_model` varchar(100) DEFAULT NULL COMMENT '设备型号',
  `robot_model` varchar(100) DEFAULT NULL COMMENT '机械手型号',
  `enable_date` date DEFAULT NULL COMMENT '启用日期',
  `service_life` int DEFAULT NULL COMMENT '使用年限（年）',
  `mold_temp_machine` varchar(100) DEFAULT NULL COMMENT '模温机',
  `chiller` varchar(100) DEFAULT NULL COMMENT '冻水机',
  `basic_mold` varchar(100) DEFAULT NULL COMMENT '基本排模',
  `spare_mold1` varchar(100) DEFAULT NULL COMMENT '备用排模1',
  `spare_mold2` varchar(100) DEFAULT NULL COMMENT '备用排模2',
  `spare_mold3` varchar(100) DEFAULT NULL COMMENT '备用排模3',
  `status` tinyint DEFAULT 1 COMMENT '状态：0-停用，1-正常，2-维修中',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` tinyint DEFAULT 0 COMMENT '删除标志：0-未删除，1-已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_equipment_no` (`equipment_no`),
  KEY `idx_group_name` (`group_name`),
  KEY `idx_machine_no` (`machine_no`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='设备表';
```

### 3.2 生产订单表（production_order）

> 用于存储生产订单信息，包含机台号、产品名称、订单数量、产能。

```sql
CREATE TABLE `production_order` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `order_no` varchar(50) NOT NULL COMMENT '订单编号（唯一）',
  `machine_no` varchar(50) NOT NULL COMMENT '机台号',
  `equipment_id` bigint DEFAULT NULL COMMENT '设备ID（关联equipment表）',
  `product_code` varchar(50) DEFAULT NULL COMMENT '产品编码',
  `product_name` varchar(100) NOT NULL COMMENT '产品名称',
  `order_quantity` int NOT NULL COMMENT '订单数量',
  `daily_capacity` int NOT NULL COMMENT '日产能（每天能生产的数量）',
  `sort_order` int DEFAULT 0 COMMENT '排序（用于确定生产优先级，按录入顺序）',
  `status` tinyint DEFAULT 0 COMMENT '状态：0-待排程，1-排程中，2-已完成',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` tinyint DEFAULT 0 COMMENT '删除标志：0-未删除，1-已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_order_no` (`order_no`),
  KEY `idx_machine_no` (`machine_no`),
  KEY `idx_equipment_id` (`equipment_id`),
  KEY `idx_product_code` (`product_code`),
  KEY `idx_sort_order` (`sort_order`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='生产订单表';
```

说明：
- 同一机台号可以配置多个产品订单（通过 `machine_no` 关联）
- `sort_order` 字段用于确定该机台号上产品的生产优先级（按录入顺序，数值越小优先级越高）
- `order_quantity` 和 `daily_capacity` 用于生产计划排程计算

### 3.3 生产计划排程表（production_schedule）

> 用于存储自动生成的生产计划排程结果。

```sql
CREATE TABLE `production_schedule` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `machine_no` varchar(50) NOT NULL COMMENT '机台号',
  `equipment_id` bigint DEFAULT NULL COMMENT '设备ID（关联equipment表）',
  `equipment_no` varchar(50) DEFAULT NULL COMMENT '设备编号',
  `schedule_date` date NOT NULL COMMENT '排程日期（避开星期天）',
  `day_number` int NOT NULL COMMENT '第几天（从开始日期起，排除星期天后的第几天）',
  `product_code` varchar(50) DEFAULT NULL COMMENT '产品编码',
  `product_name` varchar(100) NOT NULL COMMENT '产品名称',
  `production_quantity` int NOT NULL COMMENT '排产数量（等于产能）',
  `daily_capacity` int NOT NULL COMMENT '当天产能',
  `remaining_quantity` int NOT NULL COMMENT '剩余数量（订单数量 - 产能 × 已生产天数）',
  `order_id` bigint NOT NULL COMMENT '关联的生产订单ID',
  `is_sunday` tinyint DEFAULT 0 COMMENT '是否为星期天：0-否，1-是（用于标识跳过的日期）',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` tinyint DEFAULT 0 COMMENT '删除标志：0-未删除，1-已删除',
  PRIMARY KEY (`id`),
  KEY `idx_machine_no` (`machine_no`),
  KEY `idx_equipment_id` (`equipment_id`),
  KEY `idx_schedule_date` (`schedule_date`),
  KEY `idx_day_number` (`day_number`),
  KEY `idx_order_id` (`order_id`),
  UNIQUE KEY `uk_machine_date` (`machine_no`, `schedule_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='生产计划排程表';
```

说明：
- 每个机台号每天一条记录（排除星期天）
- `remaining_quantity` 为负数或0时，表示该产品已完成，下一天切换到下一个产品
- `production_quantity` 等于 `daily_capacity`（排产数量 = 产能）
- `is_sunday` 字段用于标识跳过的星期天日期（便于查询和展示）
- 可以通过 `machine_no` 和 `schedule_date` 唯一确定一条排程记录

### 3.4 生产记录表（production_record）

```sql
CREATE TABLE `production_record` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `record_no` varchar(50) NOT NULL COMMENT '记录编号',
  `equipment_id` bigint NOT NULL COMMENT '设备ID',
  `equipment_no` varchar(50) NOT NULL COMMENT '设备编号',
  `schedule_id` bigint DEFAULT NULL COMMENT '排程ID（关联production_schedule）',
  `product_code` varchar(50) DEFAULT NULL COMMENT '产品编码',
  `product_name` varchar(100) NOT NULL COMMENT '产品名称',
  `production_date` date NOT NULL COMMENT '生产日期',
  `start_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `quantity` int NOT NULL COMMENT '产量',
  `defect_quantity` int DEFAULT 0 COMMENT '不良品数量',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `deleted` tinyint DEFAULT 0 COMMENT '删除标志：0-未删除，1-已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_record_no` (`record_no`),
  KEY `idx_equipment_id` (`equipment_id`),
  KEY `idx_production_date` (`production_date`),
  KEY `idx_schedule_id` (`schedule_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='生产记录表';
```

## 4. 后端开发

### 4.1 实体类

#### ProductionOrder

```java
package com.zssystem.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@TableName("production_order")
public class ProductionOrder {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String orderNo; // 订单编号（唯一）
    
    private String machineNo; // 机台号
    
    private Long equipmentId; // 设备ID（关联equipment表）
    
    private String productCode; // 产品编码
    
    private String productName; // 产品名称
    
    private Integer orderQuantity; // 订单数量
    
    private Integer dailyCapacity; // 日产能
    
    private Integer sortOrder; // 排序（生产优先级，按录入顺序）
    
    private Integer status; // 0-待排程，1-排程中，2-已完成
    
    private String remark;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableLogic
    private Integer deleted;
}
```

#### ProductionSchedule

```java
package com.zssystem.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@TableName("production_schedule")
public class ProductionSchedule {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String machineNo; // 机台号
    
    private Long equipmentId; // 设备ID（关联equipment表）
    
    private String equipmentNo; // 设备编号
    
    private LocalDate scheduleDate; // 排程日期（避开星期天）
    
    private Integer dayNumber; // 第几天（从开始日期起，排除星期天后的天数）
    
    private String productCode; // 产品编码
    
    private String productName; // 产品名称
    
    private Integer productionQuantity; // 排产数量（等于产能）
    
    private Integer dailyCapacity; // 当天产能
    
    private Integer remainingQuantity; // 剩余数量
    
    private Long orderId; // 关联的生产订单ID
    
    private Integer isSunday; // 是否为星期天：0-否，1-是（用于标识跳过的日期）
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableLogic
    private Integer deleted;
}
```

### 4.2 DTO

#### ProductionOrderSaveDTO

```java
package com.zssystem.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class ProductionOrderSaveDTO {
    private Long id;
    
    @NotNull(message = "机台号不能为空")
    private String machineNo;
    
    private String productCode;
    
    @NotNull(message = "产品名称不能为空")
    private String productName;
    
    @NotNull(message = "订单数量不能为空")
    private Integer orderQuantity;
    
    @NotNull(message = "产能不能为空")
    private Integer dailyCapacity;
    
    private Integer sortOrder = 0; // 默认排序为0，按录入顺序自动设置
    
    private String remark;
}
```

#### ProductionScheduleQueryDTO

```java
package com.zssystem.dto;

import lombok.Data;
import java.time.LocalDate;

@Data
public class ProductionScheduleQueryDTO {
    private String machineNo; // 机台号
    private LocalDate startDate; // 排程开始日期（默认从今天开始）
}
```

#### ProductionScheduleVO

```java
package com.zssystem.vo;

import lombok.Data;
import java.time.LocalDate;
import java.util.List;

@Data
public class ProductionScheduleVO {
    private String machineNo; // 机台号
    private Long equipmentId; // 设备ID（可选）
    private String equipmentNo; // 设备编号（可选）
    private String equipmentName; // 设备名称（可选）
    private String groupName; // 组别（可选）
    private LocalDate scheduleStartDate; // 排程开始日期
    private List<ScheduleDayVO> scheduleDays; // 排程详情（排除星期天）
    private Boolean canCompleteTarget; // 是否能在指定时间内完成生产目标
}

@Data
class ScheduleDayVO {
    private Integer dayNumber; // 第几天（排除星期天后的天数）
    private LocalDate scheduleDate; // 排程日期
    private String productName; // 产品名称
    private Integer productionQuantity; // 排产数量（等于产能）
    private Integer dailyCapacity; // 产能
    private Integer remainingQuantity; // 剩余数量
}
```

### 4.3 Service实现要点

#### 生产计划排程算法（按机台号，避开星期天）

```java
@Override
@Transactional
public ProductionScheduleVO generateSchedule(String machineNo, LocalDate startDate) {
    // 1. 查询机台号对应的设备信息（可选）
    Equipment equipment = equipmentMapper.selectOne(
        new LambdaQueryWrapper<Equipment>()
            .eq(Equipment::getMachineNo, machineNo)
    );
    
    // 2. 查询该机台号的所有生产订单（按sortOrder排序，即录入顺序）
    List<ProductionOrder> orders = productionOrderMapper.selectList(
        new LambdaQueryWrapper<ProductionOrder>()
            .eq(ProductionOrder::getMachineNo, machineNo)
            .eq(ProductionOrder::getStatus, 0) // 只查询待排程的订单
            .orderByAsc(ProductionOrder::getSortOrder)
    );
    
    if (orders.isEmpty()) {
        throw new RuntimeException("该机台号未配置生产订单");
    }
    
    // 3. 删除该机台号旧的排程记录
    productionScheduleMapper.delete(new LambdaQueryWrapper<ProductionSchedule>()
        .eq(ProductionSchedule::getMachineNo, machineNo));
    
    // 4. 生成排程（避开星期天）
    List<ScheduleDayVO> scheduleDays = new ArrayList<>();
    int currentOrderIndex = 0;
    int currentOrderDays = 0; // 当前订单已生产天数
    int remainingQuantity = orders.get(currentOrderIndex).getOrderQuantity();
    int dayNumber = 0; // 排程天数（排除星期天）
    LocalDate currentDate = startDate;
    
    // 持续生成排程，直到所有订单完成或达到最大天数限制
    int maxDays = 100; // 最大排程天数限制，避免无限循环
    while (dayNumber < maxDays && currentOrderIndex < orders.size()) {
        // 判断是否为星期天，如果是则跳过
        java.time.DayOfWeek dayOfWeek = currentDate.getDayOfWeek();
        if (dayOfWeek == java.time.DayOfWeek.SUNDAY) {
            // 记录跳过的星期天
            ProductionSchedule skipSchedule = new ProductionSchedule();
            skipSchedule.setMachineNo(machineNo);
            skipSchedule.setScheduleDate(currentDate);
            skipSchedule.setIsSunday(1);
            if (equipment != null) {
                skipSchedule.setEquipmentId(equipment.getId());
                skipSchedule.setEquipmentNo(equipment.getEquipmentNo());
            }
            productionScheduleMapper.insert(skipSchedule);
            
            currentDate = currentDate.plusDays(1);
            continue;
        }
        
        dayNumber++;
        ProductionOrder currentOrder = orders.get(currentOrderIndex);
        
        // 计算剩余数量
        remainingQuantity = currentOrder.getOrderQuantity() - 
                           (currentOrder.getDailyCapacity() * currentOrderDays);
        
        // 如果剩余数量 <= 0，切换到下一个订单
        if (remainingQuantity <= 0) {
            if (currentOrderIndex < orders.size() - 1) {
                currentOrderIndex++;
                currentOrder = orders.get(currentOrderIndex);
                currentOrderDays = 0;
                remainingQuantity = currentOrder.getOrderQuantity();
            } else {
                // 所有订单已完成，退出循环
                break;
            }
        }
        
        // 创建排程记录
        ProductionSchedule schedule = new ProductionSchedule();
        schedule.setMachineNo(machineNo);
        if (equipment != null) {
            schedule.setEquipmentId(equipment.getId());
            schedule.setEquipmentNo(equipment.getEquipmentNo());
        }
        schedule.setScheduleDate(currentDate);
        schedule.setDayNumber(dayNumber);
        schedule.setProductCode(currentOrder.getProductCode());
        schedule.setProductName(currentOrder.getProductName());
        schedule.setProductionQuantity(currentOrder.getDailyCapacity()); // 排产数量 = 产能
        schedule.setDailyCapacity(currentOrder.getDailyCapacity());
        schedule.setRemainingQuantity(remainingQuantity);
        schedule.setOrderId(currentOrder.getId());
        schedule.setIsSunday(0);
        productionScheduleMapper.insert(schedule);
        
        // 添加到VO
        ScheduleDayVO dayVO = new ScheduleDayVO();
        dayVO.setDayNumber(dayNumber);
        dayVO.setScheduleDate(currentDate);
        dayVO.setProductName(currentOrder.getProductName());
        dayVO.setProductionQuantity(currentOrder.getDailyCapacity()); // 排产数量
        dayVO.setDailyCapacity(currentOrder.getDailyCapacity());
        dayVO.setRemainingQuantity(remainingQuantity);
        scheduleDays.add(dayVO);
        
        currentOrderDays++;
        currentDate = currentDate.plusDays(1);
    }
    
    // 5. 判断是否能在指定时间内完成所有订单的生产目标
    boolean canComplete = currentOrderIndex >= orders.size() - 1 && 
                         (currentOrderIndex == orders.size() - 1 ? remainingQuantity <= 0 : true);
    
    // 6. 构建返回VO
    ProductionScheduleVO vo = new ProductionScheduleVO();
    vo.setMachineNo(machineNo);
    if (equipment != null) {
        vo.setEquipmentId(equipment.getId());
        vo.setEquipmentNo(equipment.getEquipmentNo());
        vo.setEquipmentName(equipment.getEquipmentName());
        vo.setGroupName(equipment.getGroupName());
    }
    vo.setScheduleStartDate(startDate);
    vo.setScheduleDays(scheduleDays);
    vo.setCanCompleteTarget(canComplete);
    
    return vo;
}
```

## 5. 前端开发

### 5.1 生产订单管理页面

#### 5.1.1 生产订单列表
- 订单列表查询（支持按机台号、产品名称查询）
- 列表显示：订单编号、机台号、产品名称、订单数量、产能、状态、创建时间
- 支持新增、编辑、删除订单

#### 5.1.2 新增/编辑生产订单表单
表单字段：
- **机台号**（必填）：下拉选择或输入，关联设备表的机台号
- **产品名称**（必填）：输入框
- **订单数量**（必填）：数字输入框，必须大于0
- **产能**（必填）：数字输入框，必须大于0，表示日产能（每天能生产的数量）
- **备注**（可选）：文本域

说明：
- 订单按录入顺序自动设置排序（sort_order），先录入的订单优先级更高
- 一个机台号可以配置多个产品订单

### 5.2 生产计划排程页面

#### 5.2.1 排程生成
- 选择机台号（下拉选择，显示所有有订单的机台号）
- 选择排程开始日期（默认今天）
- 点击"生成生产计划"按钮，系统自动计算并生成排程（避开星期天）

#### 5.2.2 排程展示
采用表格形式展示，列包括：
- **机台号**：机台编号
- **排程日期列**：按日期顺序展示（自动跳过星期天）
  - 每个单元格显示：产品名称、排产数量、剩余数量
  - 排产数量 = 产能
  - 可以用不同颜色标识：正常生产（绿色）、产品切换（黄色）、已完成（灰色）、星期天（灰色，显示"休息"）

#### 5.2.3 排程详情查看
- 点击某个机台号，查看该机台号的详细排程计划
- 以时间轴或表格形式展示每天的：日期、产品名称、排产数量、剩余数量
- 星期天自动跳过，不安排生产
- 显示该机台号是否能在指定时间内完成所有订单的生产目标

#### 5.2.4 排程汇总分析
- 显示所有机台号的排程汇总
- 统计各产品的总订单数量、总产能、预计完成天数
- 判断是否能在指定时间内完成所有生产目标
- 支持导出排程报表（Excel）

### 5.3 Excel导出功能

#### 5.3.1 导出功能概述
生产管理模块支持多种数据的Excel导出，包括：
- **27天生产计划排程导出**：导出所有设备或指定设备的27天排程详情
- **设备生产产品配置导出**：导出设备与产品的配置关系（含订单数量和产能）
- **生产记录导出**：导出生产记录数据，支持按条件筛选
- **生产目标完成情况分析导出**：导出生产目标完成情况统计报表

#### 5.3.2 导出功能入口
- 在27天排程页面提供"导出Excel"按钮
- 在设备生产产品配置页面提供"导出配置"按钮
- 在生产记录列表页面提供"导出记录"按钮
- 在生产目标分析页面提供"导出分析报表"按钮

#### 5.3.3 Excel文件格式要求
- 文件格式：`.xlsx`（Excel 2007及以上版本）
- 文件命名规则：`生产管理_数据类型_导出日期.xlsx`，如：`生产管理_27天排程_20240120.xlsx`
- 支持中文表头和数据
- 支持数据格式化（日期、数字等）
- 支持单元格样式（表头加粗、背景色等）

### 5.4 生产记录管理
- 生产记录录入（关联排程计划）
- 记录列表查询
- 支持按设备、产品、日期查询
- 支持导出生产记录（Excel）

## 6. Excel导出功能开发

### 6.1 技术选型

#### 6.1.1 后端Excel处理库
推荐使用 **Apache POI** 或 **EasyExcel**：
- **Apache POI**：功能强大，支持复杂的Excel操作，但内存占用较大
- **EasyExcel**：阿里开源，性能优秀，支持大数据量导出，内存占用小

本项目推荐使用 **EasyExcel**，适合生产管理场景下可能的大数据量导出。

#### 6.1.2 Maven依赖

```xml
<!-- EasyExcel -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>easyexcel</artifactId>
    <version>3.3.2</version>
</dependency>
```

### 6.2 导出数据类型设计

#### 6.2.1 生产计划排程导出

**Excel结构设计：**
- **Sheet名称**：生产计划排程
- **表头行**（第1行）：
  - 机台号 | 设备名称 | 组别 | 排程日期1 | 排程日期2 | ... | 是否完成目标
- **数据行**：
  - 每行代表一个机台号
  - 第1-3列：机台基本信息
  - 第4列开始：按日期顺序展示排程信息（自动跳过星期天）
  - 每个单元格显示：产品名称/排产数量/剩余数量
  - 星期天显示为"休息"
  - 最后一列：是否能在指定时间内完成生产目标（是/否）

**示例数据格式：**
```
机台号 | 设备名称 | 组别 | 2024-01-20 | 2024-01-21 | 2024-01-22 | 休息 | 2024-01-24 | ... | 是否完成目标
01     | 注塑机1  | A组  | 产品A/100/900 | 产品A/100/800 | 产品A/100/700 | 休息 | 产品A/100/600 | ... | 是
```

#### 6.2.2 生产订单导出

**Excel结构设计：**
- **Sheet名称**：生产订单
- **表头行**（第1行）：
  - 订单编号 | 机台号 | 设备名称 | 组别 | 产品编码 | 产品名称 | 订单数量 | 产能 | 排序 | 状态 | 预计完成天数
- **数据行**：
  - 每行代表一个生产订单
  - 预计完成天数 = ceil(订单数量 / 产能)（排除星期天）

#### 6.2.3 生产记录导出

**Excel结构设计：**
- **Sheet名称**：生产记录
- **表头行**（第1行）：
  - 记录编号 | 设备编号 | 设备名称 | 产品名称 | 生产日期 | 产量 | 不良品数量 | 合格率 | 开始时间 | 结束时间 | 备注
- **数据行**：
  - 每行代表一条生产记录
  - 合格率 = (产量 / (产量 + 不良品数量)) × 100%

#### 6.2.4 生产目标完成情况分析导出

**Excel结构设计：**
- **Sheet1：设备排程汇总**
  - 表头：设备编号 | 设备名称 | 总订单数量 | 总产能 | 预计完成天数 | 是否完成目标
- **Sheet2：产品完成情况**
  - 表头：产品名称 | 总订单数量 | 总产能 | 预计完成天数 | 完成进度
- **Sheet3：27天排程详情**
  - 同6.2.1的27天排程导出格式

### 6.3 后端实现

#### 6.3.1 Excel导出工具类

```java
package com.zssystem.util;

import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class ExcelUtil {
    
    /**
     * 导出Excel（通用方法）
     * @param data 数据列表
     * @param fileName 文件名（不含扩展名）
     * @param sheetName Sheet名称
     * @param clazz 数据类（用于EasyExcel自动生成表头）
     */
    public static <T> void exportExcel(List<T> data, String fileName, String sheetName, Class<T> clazz) {
        try {
            HttpServletResponse response = getResponse();
            String encodedFileName = URLEncoder.encode(fileName, StandardCharsets.UTF_8)
                    .replaceAll("\\+", "%20");
            
            response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            response.setCharacterEncoding("utf-8");
            response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + encodedFileName + ".xlsx");
            
            EasyExcel.write(response.getOutputStream(), clazz)
                    .sheet(sheetName)
                    .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) // 自动列宽
                    .doWrite(data);
        } catch (IOException e) {
            throw new RuntimeException("导出Excel失败", e);
        }
    }
    
    private static HttpServletResponse getResponse() {
        ServletRequestAttributes attributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes == null) {
            throw new RuntimeException("无法获取HttpServletResponse");
        }
        return attributes.getResponse();
    }
    
    /**
     * 生成导出文件名
     */
    public static String generateFileName(String prefix) {
        String date = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        return prefix + "_" + date;
    }
}
```

#### 6.3.2 导出数据VO（用于EasyExcel）

```java
package com.zssystem.vo.excel;

import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.excel.annotation.write.style.ColumnWidth;
import lombok.Data;

/**
 * 生产计划排程导出VO
 */
@Data
@ColumnWidth(20)
public class ScheduleExportVO {
    @ExcelProperty(value = "机台号", index = 0)
    private String machineNo;
    
    @ExcelProperty(value = "设备名称", index = 1)
    private String equipmentName;
    
    @ExcelProperty(value = "组别", index = 2)
    private String groupName;
    
    // 动态日期列（根据实际排程日期生成）
    // 注意：星期天需要特殊处理，显示为"休息"
    
    @ExcelProperty(value = "是否完成目标", index = -1) // 最后一列
    private String canCompleteTarget;
}
```

#### 6.3.3 Controller导出接口

```java
@GetMapping("/schedule/export")
public void exportSchedule(ProductionScheduleQueryDTO queryDTO, HttpServletResponse response) {
    // 1. 查询排程数据
    List<ProductionScheduleVO> schedules = scheduleService.getScheduleList(queryDTO);
    
    // 2. 转换为导出VO（需要处理动态日期列和星期天）
    List<ScheduleExportVO> exportData = convertToExportVO(schedules);
    
    // 3. 导出Excel
    String fileName = ExcelUtil.generateFileName("生产管理_生产计划排程");
    ExcelUtil.exportExcel(exportData, fileName, "生产计划排程", ScheduleExportVO.class);
}
```

### 6.4 前端实现

#### 6.4.1 导出按钮

```typescript
import { Button } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';

const handleExport = async () => {
  try {
    const params = {
      // 查询参数
    };
    const response = await request.get('/api/production/schedule/export', {
      params,
      responseType: 'blob', // 重要：指定响应类型为blob
    });
    
    // 创建下载链接
    const blob = new Blob([response], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `生产管理_27天排程_${new Date().toISOString().split('T')[0]}.xlsx`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
    
    message.success('导出成功');
  } catch (error: any) {
    message.error('导出失败：' + error.message);
  }
};

<Button type="primary" icon={<DownloadOutlined />} onClick={handleExport}>
  导出Excel
</Button>
```

#### 6.4.2 封装导出工具函数

```typescript
// frontend/src/utils/excel.ts
import request from './request';
import { message } from 'antd';

export const exportExcel = async (url: string, params: any, filename: string) => {
  try {
    const response = await request.get(url, {
      params,
      responseType: 'blob',
    });
    
    const blob = new Blob([response], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    });
    const downloadUrl = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(downloadUrl);
    
    message.success('导出成功');
  } catch (error: any) {
    message.error('导出失败：' + (error.message || '未知错误'));
  }
};
```

### 6.5 Excel格式设计规范

#### 6.5.1 表头样式
- 背景色：浅灰色（#F2F2F2）
- 字体：加粗、12号
- 对齐方式：居中
- 行高：25px

#### 6.5.2 数据样式
- 字体：11号、宋体
- 对齐方式：文本左对齐，数字右对齐
- 日期格式：YYYY-MM-DD
- 数字格式：整数显示，保留0位小数

#### 6.5.3 特殊标识
- 剩余数量 ≤ 0：单元格背景色为绿色（表示产品已完成）
- 产品切换：单元格背景色为黄色（表示当天切换产品）
- 无法完成目标：整行背景色为红色（表示该设备无法在27天内完成目标）

### 6.6 导出功能接口设计

#### 6.6.1 生产计划排程导出接口

```java
@GetMapping("/schedule/export")
public void exportSchedule(
    @RequestParam(required = false) String machineNo,
    @RequestParam(required = false) LocalDate startDate,
    HttpServletResponse response
) {
    // 导出逻辑
}
```

#### 6.6.2 生产订单导出接口

```java
@GetMapping("/order/export")
public void exportProductionOrder(
    @RequestParam(required = false) String machineNo,
    @RequestParam(required = false) String productName,
    HttpServletResponse response
) {
    // 导出逻辑
}
```

#### 6.6.3 生产记录导出接口

```java
@GetMapping("/record/export")
public void exportProductionRecord(
    ProductionRecordQueryDTO queryDTO,
    HttpServletResponse response
) {
    // 导出逻辑
}
```

## 7. 开发要点

### 7.1 生产计划排程算法核心逻辑（按机台号，避开星期天）

```java
// 伪代码
currentDate = startDate;
dayNumber = 0; // 排程天数（排除星期天）

while (还有未完成的订单) {
    // 判断是否为星期天
    if (currentDate是星期天) {
        记录跳过该日期（isSunday = 1）;
        currentDate = currentDate + 1天;
        continue; // 跳过星期天
    }
    
    dayNumber++;
    currentOrder = orders[currentOrderIndex];
    
    // 计算剩余数量
    remainingQuantity = currentOrder.orderQuantity - 
                       (currentOrder.dailyCapacity * currentOrderDays);
    
    // 如果剩余数量 <= 0，切换到下一个订单
    if (remainingQuantity <= 0) {
        if (还有下一个订单) {
            currentOrderIndex++;
            currentOrder = orders[currentOrderIndex];
            currentOrderDays = 0;
            remainingQuantity = currentOrder.orderQuantity;
        } else {
            break; // 所有订单已完成
        }
    }
    
    // 记录第dayNumber天的排程
    schedule[dayNumber] = {
        scheduleDate: currentDate,
        productName: currentOrder.productName,
        productionQuantity: currentOrder.dailyCapacity, // 排产数量 = 产能
        dailyCapacity: currentOrder.dailyCapacity,
        remainingQuantity: remainingQuantity
    };
    
    currentOrderDays++;
    currentDate = currentDate + 1天;
}
```

### 7.2 生产目标完成判断

- 遍历所有设备的所有产品配置
- 计算每个产品需要的生产天数：`ceil(订单数量 / 日产能)`
- 根据排程结果，统计每个产品实际分配的生产天数
- 判断：实际分配天数 ≤ 27天，且所有产品都能完成，则能在27天内完成生产目标

### 7.3 Excel导出注意事项

1. **大数据量处理**：使用EasyExcel的流式写入，避免内存溢出
2. **文件下载**：前端需要设置 `responseType: 'blob'`，后端设置正确的Content-Type
3. **中文文件名**：使用URL编码处理中文文件名，避免浏览器下载时乱码
4. **数据格式化**：日期、数字等需要格式化显示，提升可读性
5. **样式设置**：合理使用单元格样式，提升Excel可读性
6. **多Sheet支持**：复杂报表可以使用多个Sheet，如生产目标分析报表

## 8. 注意事项

1. **机台号关联**：生产订单通过机台号关联设备，机台号必须存在于设备表中
2. **订单排序**：通过 `sort_order` 字段确定产品生产优先级，按录入顺序自动设置，数值越小优先级越高
3. **剩余数量计算**：`剩余数量 = 订单数量 - 产能 × 已生产天数`，当剩余数量 ≤ 0 时，切换到下一个订单
4. **避开星期天**：排程时自动跳过星期天，不在星期天安排生产，星期天日期会记录但标记为休息日
5. **排产数量**：每天排产数量等于该产品的产能数量（`production_quantity = daily_capacity`）
6. **排程唯一性**：每个机台号每天只能有一条排程记录（`machine_no + schedule_date` 唯一）
7. **排程重新生成**：当生产订单发生变化时，需要重新生成排程计划
8. **订单状态管理**：订单状态包括：待排程（0）、排程中（1）、已完成（2）
9. **删除使用逻辑删除**
10. **Excel导出**：使用EasyExcel进行导出，支持大数据量，注意文件下载的Content-Type设置和中文文件名编码
11. **Excel格式**：保持统一的表头样式和数据格式，提升报表可读性，星期天日期在Excel中显示为"休息"
