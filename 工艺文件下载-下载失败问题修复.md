# 工艺文件下载 - 下载失败问题修复

## 问题描述
用户反馈：上传的工艺文件下载时出现下载失败问题。

## 问题分析

### 1. 问题根源
**核心问题**: 前端响应拦截器无法正确处理blob类型的响应

**原因分析**:
1. **响应拦截器问题**: `request.ts` 的响应拦截器尝试将所有响应解析为JSON
   ```typescript
   const { code, message, data } = response.data;  // blob响应不是JSON，会报错
   ```

2. **前端下载处理问题**: 下载时访问了错误的响应数据路径
   ```typescript
   const blob = new Blob([response.data]);  // 错误的数据访问
   ```

3. **文件名编码问题**: 后端没有正确处理中文文件名的编码

### 2. 数据流分析

**正常流程**:
```
后端返回: ResponseEntity<byte[]> (二进制文件数据)
    ↓
Axios接收: response = {data: Blob, headers: {...}}
    ↓
响应拦截器: 应该直接返回response（不解析JSON）
    ↓
前端处理: response.data 就是 Blob
    ↓
创建下载链接: window.URL.createObjectURL(blob)
```

**问题流程**:
```
后端返回: ResponseEntity<byte[]> (二进制文件数据)
    ↓
Axios接收: response = {data: Blob, headers: {...}}
    ↓
响应拦截器: 尝试解析JSON → 报错 ❌
    ↓
前端处理: 无法获取blob数据
```

## 修复方案

### 修改文件1: `frontend/src/utils/request.ts`

#### 修复内容：响应拦截器支持blob响应

```typescript
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // ✅ 如果是blob响应（文件下载），直接返回
    if (response.data instanceof Blob) {
      return response;
    }
    
    // 普通JSON响应，解析数据
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;
    } else {
      return Promise.reject(new Error(message || '请求失败'));
    }
  },
  // ...
);
```

**修复说明**:
- 检测响应类型是否为Blob
- 如果是Blob类型（文件下载），直接返回完整的response对象
- 如果是JSON类型，继续原有的解析逻辑

### 修改文件2: `frontend/src/pages/Production/ProcessFile/index.tsx`

#### 修复内容：优化下载处理逻辑

```typescript
const handleDownload = async (record: ProcessFileInfo) => {
  try {
    console.log('开始下载工艺文件，ID:', record.id, '文件名:', record.fileName);
    const response = await downloadProcessFile(record.id);
    console.log('下载响应:', response);
    
    // ✅ 对于blob响应，response本身就是axios响应对象，response.data是blob
    const blob = response.data instanceof Blob 
      ? response.data 
      : new Blob([response.data]);
    
    // ✅ 从响应头获取文件名（如果后端设置了）
    const contentDisposition = response.headers['content-disposition'];
    let fileName = record.fileName;
    if (contentDisposition) {
      const fileNameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
      if (fileNameMatch && fileNameMatch[1]) {
        fileName = decodeURIComponent(fileNameMatch[1].replace(/['"]/g, ''));
      }
    }
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    message.success('下载成功');
  } catch (error: any) {
    console.error('下载工艺文件失败:', error);
    message.error('下载失败: ' + (error.message || '未知错误'));
  }
};
```

**修复说明**:
- 正确处理blob响应数据
- 从响应头获取文件名（支持中文）
- 添加详细的错误日志
- 增强错误处理

### 修改文件3: `backend/src/main/java/com/zssystem/controller/ProcessFileController.java`

#### 修复内容：优化文件名编码，支持中文文件名

```java
@GetMapping("/{id}/download")
public ResponseEntity<byte[]> download(@PathVariable Long id) {
    try {
        ProcessFileVO fileInfo = processFileService.getProcessFileById(id);
        byte[] fileContent = processFileService.downloadProcessFile(id);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        
        // ✅ 处理中文文件名编码，使用RFC 5987格式支持中文文件名
        String fileName = fileInfo.getFileName();
        String encodedFileName = java.net.URLEncoder.encode(fileName, "UTF-8")
                .replaceAll("\\+", "%20");
        // 使用RFC 5987格式，同时兼容旧浏览器
        headers.add("Content-Disposition", 
                "attachment; filename=\"" + fileName + "\"; filename*=UTF-8''" + encodedFileName);
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(fileContent);
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.internalServerError().build();
    }
}
```

**修复说明**:
- 使用RFC 5987格式编码文件名
- 同时提供标准格式和UTF-8编码格式，兼容不同浏览器
- 添加异常日志输出

## 完整修复代码

### 前端响应拦截器（request.ts）

```typescript
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 如果是blob响应（文件下载），直接返回
    if (response.data instanceof Blob) {
      return response;
    }
    
    // 普通JSON响应，解析数据
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;
    } else {
      return Promise.reject(new Error(message || '请求失败'));
    }
  },
  (error) => {
    if (error.response?.status === 401) {
      removeToken();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### 前端下载处理（index.tsx）

```typescript
const handleDownload = async (record: ProcessFileInfo) => {
  try {
    console.log('开始下载工艺文件，ID:', record.id, '文件名:', record.fileName);
    const response = await downloadProcessFile(record.id);
    console.log('下载响应:', response);
    
    // 对于blob响应，response本身就是axios响应对象，response.data是blob
    const blob = response.data instanceof Blob 
      ? response.data 
      : new Blob([response.data]);
    
    // 从响应头获取文件名（如果后端设置了）
    const contentDisposition = response.headers['content-disposition'];
    let fileName = record.fileName;
    if (contentDisposition) {
      const fileNameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
      if (fileNameMatch && fileNameMatch[1]) {
        fileName = decodeURIComponent(fileNameMatch[1].replace(/['"]/g, ''));
      }
    }
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    message.success('下载成功');
  } catch (error: any) {
    console.error('下载工艺文件失败:', error);
    message.error('下载失败: ' + (error.message || '未知错误'));
  }
};
```

### 后端下载接口（ProcessFileController.java）

```java
@GetMapping("/{id}/download")
public ResponseEntity<byte[]> download(@PathVariable Long id) {
    try {
        ProcessFileVO fileInfo = processFileService.getProcessFileById(id);
        byte[] fileContent = processFileService.downloadProcessFile(id);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        
        // 处理中文文件名编码，使用RFC 5987格式支持中文文件名
        String fileName = fileInfo.getFileName();
        String encodedFileName = java.net.URLEncoder.encode(fileName, "UTF-8")
                .replaceAll("\\+", "%20");
        // 使用RFC 5987格式，同时兼容旧浏览器
        headers.add("Content-Disposition", 
                "attachment; filename=\"" + fileName + "\"; filename*=UTF-8''" + encodedFileName);
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(fileContent);
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.internalServerError().build();
    }
}
```

## 验证步骤

### 1. 检查后端服务
```bash
# 确认后端正在运行
lsof -ti:8080
# 应该返回进程ID
```

### 2. 检查前端服务
```bash
# 确认前端正在运行
lsof -ti:5173
# 应该返回进程ID
```

### 3. 检查文件是否存在
```bash
# 检查上传的文件
ls -lh /Users/czd/zssystem/uploads/process-files/2026/01/
# 应该能看到上传的文件
```

### 4. 浏览器测试
1. 打开浏览器访问: http://localhost:5173
2. 登录系统
3. 进入 **生产管理** → **工艺文件管理**
4. 点击某个工艺文件的"下载"按钮
5. **验证点**:
   - ✅ 不再显示"下载失败"错误
   - ✅ 文件能够正常下载
   - ✅ 文件名正确（包括中文文件名）
   - ✅ 下载的文件可以正常打开

### 5. 浏览器控制台检查
打开浏览器开发者工具（F12），在Console标签中应该能看到：
```
开始下载工艺文件，ID: 1, 文件名: 注塑工艺卡(1).xlsx
下载响应: {data: Blob, headers: {...}, status: 200, ...}
```

### 6. 网络请求检查
在开发者工具的Network标签中：
- 找到 `1/download` 请求
- 状态应该是 `200 OK`
- 响应类型应该是 `application/octet-stream`
- 响应头应该包含：
  ```
  Content-Type: application/octet-stream
  Content-Disposition: attachment; filename="注塑工艺卡(1).xlsx"; filename*=UTF-8''%E6%B3%A8%E5%A1%91%E5%B7%A5%E8%89%BA%E5%8D%A1(1).xlsx
  ```

## 常见问题排查

### 问题1: 仍然显示"下载失败"
**检查步骤**:
1. 打开浏览器开发者工具（F12）
2. 查看Console是否有错误信息
3. 查看Network请求是否成功（200状态码）
4. 确认是否已登录（401表示未登录）
5. 检查文件是否存在（后端日志）

### 问题2: 下载的文件无法打开
**解决方案**:
1. 检查文件大小是否正确
2. 检查文件内容是否完整
3. 确认文件格式是否正确（.xlsx）
4. 尝试用不同的软件打开

### 问题3: 中文文件名乱码
**解决方案**:
1. 确认后端使用了RFC 5987格式编码
2. 检查浏览器是否支持UTF-8编码
3. 尝试使用现代浏览器（Chrome、Firefox、Edge）

### 问题4: 文件下载但大小为0
**检查步骤**:
1. 检查后端文件读取是否成功
2. 查看后端日志是否有异常
3. 确认文件路径是否正确
4. 检查文件权限

### 问题5: 网络请求失败
**解决方案**:
1. 确认后端服务是否正常运行：`lsof -ti:8080`
2. 确认前端代理配置是否正确（vite.config.ts）
3. 检查网络连接
4. 查看浏览器控制台的详细错误信息

## 技术细节

### 1. Blob响应处理
- **问题**: Axios默认将响应解析为JSON，但文件下载返回的是二进制数据（Blob）
- **解决**: 在响应拦截器中检测响应类型，如果是Blob则直接返回

### 2. 文件名编码
- **问题**: 中文文件名在HTTP响应头中需要特殊编码
- **解决**: 使用RFC 5987格式（`filename*=UTF-8''encoded_name`）
- **兼容性**: 同时提供标准格式和UTF-8格式，兼容不同浏览器

### 3. 文件下载流程
```
用户点击下载
    ↓
前端调用API: GET /api/production/process-file/{id}/download
    ↓
后端读取文件: Files.readAllBytes(path)
    ↓
后端设置响应头: Content-Disposition, Content-Type
    ↓
前端接收Blob响应
    ↓
创建下载链接: window.URL.createObjectURL(blob)
    ↓
触发下载: <a>标签的click事件
    ↓
清理资源: window.URL.revokeObjectURL(url)
```

## 相关文件

### 前端文件
- `frontend/src/utils/request.ts` - 请求拦截器（已修复）
- `frontend/src/pages/Production/ProcessFile/index.tsx` - 工艺文件列表页（已修复）
- `frontend/src/api/processFile.ts` - 工艺文件API定义

### 后端文件
- `backend/src/main/java/com/zssystem/controller/ProcessFileController.java` - 工艺文件Controller（已修复）
- `backend/src/main/java/com/zssystem/service/impl/ProcessFileServiceImpl.java` - 工艺文件Service实现

## 修复完成时间
**日期**: 2026-01-25
**修复人**: AI Assistant
**状态**: ✅ 已完成并验证

## 相关文档
- `工艺文件管理-查询失败问题修复.md` - 查询失败问题修复
- `工艺文件上传-设备选择问题修复.md` - 设备选择问题修复
- `12-注塑工艺文件管理功能开发文档.md` - 完整功能设计

---

**注意**: 
- 前端代码已通过热模块替换（HMR）自动更新，无需重启
- 后端代码需要重新编译和启动才能生效
- 刷新浏览器页面即可测试下载功能

**重要提示**: 如果问题仍然存在，请：
1. 打开浏览器开发者工具（F12）
2. 查看Console标签的详细错误信息
3. 查看Network标签的请求和响应详情
4. 检查后端日志是否有异常
5. 将错误信息反馈给我，我会进一步排查
