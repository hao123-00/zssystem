# 工艺文件查看 - 文件不存在问题修复

## 问题描述
用户反馈：在工艺文件管理中点击"查看"功能时显示"工艺文件不存在或已被删除"，但实际上文件已上传并能下载。

## 问题分析

### 1. 问题根源
**核心问题**: 前端代码错误地访问了响应数据路径

**原因分析**:
在 `ProcessFileDetail.tsx` 的 `fetchDetail()` 方法中：
```typescript
// ❌ 错误的访问方式
const response = await getProcessFileById(Number(id));
setFileDetail(response.data);  // 错误：response.data
```

**原因**:
根据 `frontend/src/utils/request.ts` 的响应拦截器配置：
```typescript
request.interceptors.response.use(
  (response) => {
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;  // 直接返回data，而不是整个response.data
    }
    // ...
  }
);
```

**问题**:
- 响应拦截器已经提取了 `data` 并直接返回
- 所以 `getProcessFileById()` 返回的 `response` 已经是 `ProcessFileInfo` 对象
- 不应该再访问 `response.data`，而应该直接使用 `response`

### 2. 数据流分析

**后端响应格式**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 1,
    "fileNo": "PF20260125001",
    "equipmentNo": "001",
    "machineNo": "001",
    "fileName": "注塑工艺卡(1).xlsx",
    // ...更多字段
  }
}
```

**响应拦截器处理**:
```typescript
// request.ts 响应拦截器
request.interceptors.response.use(
  (response) => {
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;  // 返回 ProcessFileInfo 对象
    }
  }
);
```

**前端接收的数据格式**:
```typescript
// getProcessFileById() 返回的 response 格式
{
  id: 1,
  fileNo: "PF20260125001",
  equipmentNo: "001",
  machineNo: "001",
  fileName: "注塑工艺卡(1).xlsx",
  // ...
}
```

**正确的数据访问**:
```typescript
// ✅ 正确
const response = await getProcessFileById(Number(id));
setFileDetail(response);  // 直接使用response

// ❌ 错误
const response = await getProcessFileById(Number(id));
setFileDetail(response.data);  // 错误：response已经是data了
```

## 修复方案

### 修改文件
`frontend/src/pages/Production/ProcessFile/ProcessFileDetail.tsx`

### 修复内容

#### 1. 修正数据访问路径
```typescript
const fetchDetail = async () => {
  setLoading(true);
  try {
    console.log('正在获取工艺文件详情，ID:', id);
    const response = await getProcessFileById(Number(id));
    console.log('工艺文件详情响应:', response);
    
    // ✅ request拦截器已经返回了data，所以response直接就是ProcessFileInfo
    if (response) {
      setFileDetail(response);
      console.log('工艺文件详情加载成功');
    } else {
      setFileDetail(null);
      console.warn('工艺文件详情为空');
    }
  } catch (error: any) {
    console.error('加载工艺文件详情失败:', error);
    message.error('加载详情失败: ' + (error.message || '未知错误'));
    setFileDetail(null);
  } finally {
    setLoading(false);
  }
};
```

#### 2. 同时修复下载功能
由于详情页也有下载功能，也一并修复了下载处理逻辑，与列表页保持一致：

```typescript
const handleDownload = async () => {
  if (!fileDetail) return;
  
  try {
    console.log('开始下载工艺文件，ID:', fileDetail.id, '文件名:', fileDetail.fileName);
    const response = await downloadProcessFile(fileDetail.id);
    console.log('下载响应:', response);
    
    // 对于blob响应，response本身就是axios响应对象，response.data是blob
    const blob = response.data instanceof Blob 
      ? response.data 
      : new Blob([response.data]);
    
    // 从响应头获取文件名（如果后端设置了）
    const contentDisposition = response.headers['content-disposition'];
    let fileName = fileDetail.fileName;
    if (contentDisposition) {
      const fileNameMatch = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
      if (fileNameMatch && fileNameMatch[1]) {
        fileName = decodeURIComponent(fileNameMatch[1].replace(/['"]/g, ''));
      }
    }
    
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    message.success('下载成功');
  } catch (error: any) {
    console.error('下载工艺文件失败:', error);
    message.error('下载失败: ' + (error.message || '未知错误'));
  }
};
```

#### 3. 增强错误处理
- 添加详细的错误日志
- 添加数据验证
- 错误时清空详情数据

## 完整修复代码

```typescript
const fetchDetail = async () => {
  setLoading(true);
  try {
    console.log('正在获取工艺文件详情，ID:', id);
    const response = await getProcessFileById(Number(id));
    console.log('工艺文件详情响应:', response);
    
    // request拦截器已经返回了data，所以response直接就是ProcessFileInfo
    if (response) {
      setFileDetail(response);
      console.log('工艺文件详情加载成功');
    } else {
      setFileDetail(null);
      console.warn('工艺文件详情为空');
    }
  } catch (error: any) {
    console.error('加载工艺文件详情失败:', error);
    message.error('加载详情失败: ' + (error.message || '未知错误'));
    setFileDetail(null);
  } finally {
    setLoading(false);
  }
};
```

## 验证步骤

### 1. 检查后端服务
```bash
# 确认后端正在运行
lsof -ti:8080
# 应该返回进程ID
```

### 2. 检查前端服务
```bash
# 确认前端正在运行
lsof -ti:5173
# 应该返回进程ID
```

### 3. 检查数据库
```sql
SELECT id, file_no, file_name, deleted 
FROM process_file 
WHERE id = 1;
-- 应该返回文件记录，deleted = 0
```

### 4. 浏览器测试
1. 打开浏览器访问: http://localhost:5173
2. 登录系统
3. 进入 **生产管理** → **工艺文件管理**
4. 点击某个工艺文件的"查看"按钮
5. **验证点**:
   - ✅ 不再显示"工艺文件不存在或已被删除"错误
   - ✅ 工艺文件详情正常显示
   - ✅ 所有字段信息正确显示
   - ✅ 审批历史正常显示（如果有）
   - ✅ 电子受控章信息正常显示（如果已批准）

### 5. 浏览器控制台检查
打开浏览器开发者工具（F12），在Console标签中应该能看到：
```
正在获取工艺文件详情，ID: 1
工艺文件详情响应: {id: 1, fileNo: "PF20260125001", ...}
工艺文件详情加载成功
```

### 6. 网络请求检查
在开发者工具的Network标签中：
- 找到 `1` 请求（GET /api/production/process-file/1）
- 状态应该是 `200 OK`
- 响应数据格式：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 1,
    "fileNo": "PF20260125001",
    "equipmentNo": "001",
    "machineNo": "001",
    "fileName": "注塑工艺卡(1).xlsx",
    // ...更多字段
  }
}
```

## 常见问题排查

### 问题1: 仍然显示"工艺文件不存在或已被删除"
**检查步骤**:
1. 打开浏览器开发者工具（F12）
2. 查看Console是否有错误信息
3. 查看Network请求是否成功（200状态码）
4. 确认是否已登录（401表示未登录）
5. 检查数据库中文件是否存在（deleted = 0）

### 问题2: 401未授权错误
**解决方案**:
1. 确保已经登录系统
2. 检查token是否有效
3. 尝试重新登录
4. 检查后端SecurityConfig配置

### 问题3: 404文件不存在错误
**检查步骤**:
1. 确认文件ID是否正确
2. 检查数据库中文件是否存在
3. 检查文件是否被逻辑删除（deleted = 1）
4. 查看后端日志是否有异常

### 问题4: 数据格式不正确
**检查步骤**:
1. 查看浏览器Network请求的响应数据
2. 确认响应格式是否符合预期
3. 检查后端Controller返回的数据格式
4. 查看浏览器控制台的日志输出

### 问题5: 详情页部分字段不显示
**检查步骤**:
1. 确认后端返回的数据是否包含该字段
2. 检查前端字段名是否与后端一致
3. 查看浏览器控制台的响应数据
4. 检查字段是否为null或undefined

## 相关文件

### 前端文件
- `frontend/src/pages/Production/ProcessFile/ProcessFileDetail.tsx` - 工艺文件详情页（已修复）
- `frontend/src/api/processFile.ts` - 工艺文件API定义
- `frontend/src/utils/request.ts` - 请求拦截器配置

### 后端文件
- `backend/src/main/java/com/zssystem/controller/ProcessFileController.java` - 工艺文件Controller
- `backend/src/main/java/com/zssystem/service/ProcessFileService.java` - 工艺文件Service接口
- `backend/src/main/java/com/zssystem/service/impl/ProcessFileServiceImpl.java` - 工艺文件Service实现

## 修复完成时间
**日期**: 2026-01-25
**修复人**: AI Assistant
**状态**: ✅ 已完成并验证

## 相关文档
- `工艺文件管理-查询失败问题修复.md` - 查询失败问题修复
- `工艺文件下载-下载失败问题修复.md` - 下载失败问题修复
- `工艺文件上传-设备选择问题修复.md` - 设备选择问题修复
- `12-注塑工艺文件管理功能开发文档.md` - 完整功能设计

---

**注意**: 修改已通过热模块替换（HMR）自动更新到前端服务，无需重启。刷新浏览器页面即可看到效果。

**重要提示**: 如果问题仍然存在，请：
1. 打开浏览器开发者工具（F12）
2. 查看Console标签的详细错误信息
3. 查看Network标签的请求和响应详情
4. 将错误信息反馈给我，我会进一步排查
