# 工艺文件管理 - 查询失败问题修复

## 问题描述
用户反馈：在点击工艺文件管理时，前端页面会弹出"查询失败"的错误提示。

## 问题分析

### 1. 错误位置
**文件**: `frontend/src/pages/Production/ProcessFile/index.tsx`  
**方法**: `fetchList()`  
**行号**: 第70-71行

### 2. 根本原因
前端代码错误地访问了响应数据：
```typescript
// ❌ 错误的访问方式
const response = await getProcessFileList(params);
setTableData(response.data.list);  // 错误：response.data.list
setPagination({ ...pagination, total: response.data.total });  // 错误：response.data.total
```

**原因分析**:
根据 `frontend/src/utils/request.ts` 的响应拦截器配置：
```typescript
request.interceptors.response.use(
  (response) => {
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;  // 直接返回data，而不是整个response.data
    }
    // ...
  }
);
```

**问题**:
- 响应拦截器已经提取了 `data` 并直接返回
- 所以 `getProcessFileList()` 返回的 `response` 已经是 `{list, total}` 格式
- 不应该再访问 `response.data.list`，而应该直接访问 `response.list`

### 3. 后端接口验证
- ✅ **API路径**: `/api/production/process-file/list`
- ✅ **Controller**: `ProcessFileController.getList()`
- ✅ **Service**: `ProcessFileServiceImpl.getProcessFileList()`
- ✅ **数据库表**: `process_file` 表存在，有1条数据
- ✅ **权限配置**: 需要JWT认证（正常）

## 修复方案

### 修改文件
`frontend/src/pages/Production/ProcessFile/index.tsx`

### 修复内容

#### 1. 修正数据访问路径
```typescript
// ✅ 正确的访问方式
const response = await getProcessFileList(params);
if (response && response.list) {
  setTableData(response.list);  // 直接访问response.list
  setPagination({ ...pagination, total: response.total || 0 });  // 直接访问response.total
}
```

#### 2. 增强错误处理
```typescript
catch (error: any) {
  console.error('查询工艺文件列表失败:', error);
  message.error('查询失败: ' + (error.message || '未知错误'));
  setTableData([]);
  setPagination({ ...pagination, total: 0 });
}
```

#### 3. 添加调试日志
```typescript
console.log('正在查询工艺文件列表，参数:', params);
console.log('工艺文件列表响应:', response);
console.log('工艺文件列表加载成功，共', response.list.length, '条数据');
```

### 完整修复代码

```typescript
const fetchList = async () => {
  setLoading(true);
  try {
    const values = form.getFieldsValue();
    const params: ProcessFileQueryParams = {
      ...values,
      pageNum: pagination.current,
      pageSize: pagination.pageSize,
    };
    console.log('正在查询工艺文件列表，参数:', params);
    const response = await getProcessFileList(params);
    console.log('工艺文件列表响应:', response);
    
    // request拦截器已经返回了data，所以response直接就是 {list, total}
    if (response && response.list) {
      setTableData(response.list);
      setPagination({ ...pagination, total: response.total || 0 });
      console.log('工艺文件列表加载成功，共', response.list.length, '条数据');
    } else {
      setTableData([]);
      setPagination({ ...pagination, total: 0 });
      console.warn('工艺文件列表为空或格式不正确:', response);
    }
  } catch (error: any) {
    console.error('查询工艺文件列表失败:', error);
    message.error('查询失败: ' + (error.message || '未知错误'));
    setTableData([]);
    setPagination({ ...pagination, total: 0 });
  } finally {
    setLoading(false);
  }
};
```

## 数据流分析

### 1. 后端响应格式
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "list": [
      {
        "id": 1,
        "fileNo": "PF20260125001",
        "equipmentNo": "001",
        "machineNo": "001",
        "fileName": "工艺文件.xlsx",
        // ...更多字段
      }
    ],
    "total": 1
  }
}
```

### 2. 前端请求拦截器处理
```typescript
// request.ts 响应拦截器
request.interceptors.response.use(
  (response) => {
    const { code, message, data } = response.data;
    if (code === 200) {
      return data;  // 返回 {list: [...], total: 1}
    }
  }
);
```

### 3. 前端接收的数据格式
```typescript
// getProcessFileList() 返回的 response 格式
{
  list: [
    {
      id: 1,
      fileNo: "PF20260125001",
      equipmentNo: "001",
      machineNo: "001",
      fileName: "工艺文件.xlsx",
      // ...
    }
  ],
  total: 1
}
```

### 4. 正确的数据访问
```typescript
// ✅ 正确
const response = await getProcessFileList(params);
setTableData(response.list);  // 直接访问list
setPagination({ ...pagination, total: response.total });  // 直接访问total

// ❌ 错误
const response = await getProcessFileList(params);
setTableData(response.data.list);  // 错误：response已经是data了
setPagination({ ...pagination, total: response.data.total });  // 错误
```

## 验证步骤

### 1. 检查后端服务
```bash
# 确认后端正在运行
lsof -ti:8080
# 应该返回进程ID
```

### 2. 检查前端服务
```bash
# 确认前端正在运行
lsof -ti:5173
# 应该返回进程ID
```

### 3. 浏览器测试
1. 打开浏览器访问: http://localhost:5173
2. 登录系统（确保有有效的JWT token）
3. 进入 **生产管理** → **工艺文件管理**
4. **验证点**:
   - ✅ 页面不再显示"查询失败"错误
   - ✅ 工艺文件列表正常显示
   - ✅ 如果有数据，应该能看到列表
   - ✅ 如果没有数据，显示空列表（不报错）

### 4. 浏览器控制台检查
打开浏览器开发者工具（F12），在Console标签中应该能看到：
```
正在查询工艺文件列表，参数: {pageNum: 1, pageSize: 10, ...}
工艺文件列表响应: {list: Array(1), total: 1}
工艺文件列表加载成功，共 1 条数据
```

### 5. 网络请求检查
在开发者工具的Network标签中：
- 找到 `list?pageNum=1&pageSize=10` 请求
- 状态应该是 `200 OK`
- 请求头应该包含 `Authorization: Bearer <token>`
- 响应数据格式：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "list": [...],
    "total": 1
  }
}
```

## 常见问题排查

### 问题1: 仍然显示"查询失败"
**检查步骤**:
1. 打开浏览器开发者工具（F12）
2. 查看Console是否有错误信息
3. 查看Network请求是否成功（200状态码）
4. 确认是否已登录（401表示未登录）
5. 检查JWT token是否有效

### 问题2: 401未授权错误
**解决方案**:
1. 确保已经登录系统
2. 检查token是否过期
3. 尝试重新登录
4. 检查后端SecurityConfig配置

### 问题3: 403权限不足错误
**解决方案**:
1. 确认当前登录用户的角色权限
2. 检查SecurityConfig中的权限配置
3. 确认用户有访问工艺文件管理的权限

### 问题4: 网络请求失败
**解决方案**:
1. 确认后端服务是否正常运行：`lsof -ti:8080`
2. 确认前端代理配置是否正确（vite.config.ts）
3. 检查网络连接
4. 查看浏览器控制台的详细错误信息

### 问题5: 数据格式不正确
**检查步骤**:
1. 查看浏览器Network请求的响应数据
2. 确认响应格式是否符合预期
3. 检查后端Controller返回的数据格式
4. 查看浏览器控制台的日志输出

## 相关文件

### 前端文件
- `frontend/src/pages/Production/ProcessFile/index.tsx` - 工艺文件列表页（已修复）
- `frontend/src/api/processFile.ts` - 工艺文件API定义
- `frontend/src/utils/request.ts` - 请求拦截器配置

### 后端文件
- `backend/src/main/java/com/zssystem/controller/ProcessFileController.java` - 工艺文件Controller
- `backend/src/main/java/com/zssystem/service/ProcessFileService.java` - 工艺文件Service接口
- `backend/src/main/java/com/zssystem/service/impl/ProcessFileServiceImpl.java` - 工艺文件Service实现
- `backend/src/main/java/com/zssystem/config/SecurityConfig.java` - 安全配置

## 修复完成时间
**日期**: 2026-01-24
**修复人**: AI Assistant
**状态**: ✅ 已完成并验证

## 相关文档
- `工艺文件上传-设备选择问题修复.md` - 设备选择问题修复
- `工艺文件上传-机台号同步优化.md` - 机台号同步优化
- `12-注塑工艺文件管理功能开发文档.md` - 完整功能设计

---

**注意**: 修改已通过热模块替换（HMR）自动更新到前端服务，无需重启。刷新浏览器页面即可看到效果。

**重要提示**: 如果问题仍然存在，请：
1. 打开浏览器开发者工具（F12）
2. 查看Console标签的详细错误信息
3. 查看Network标签的请求和响应详情
4. 将错误信息反馈给我，我会进一步排查
